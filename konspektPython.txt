язык с динамической типизацией
ТИПЫ ДАННЫХ 
int, float, boolean, string, list, None
type(переменная) - тип переменной
peremennaya: str = "" явно задали тип str переменной peremennaya
# комментарий
\n переход на новую строку
'hello "word'
print(a, '-', b, '-', c) вывод или 
print('{} - {} - {}'.format(a,b,c)) или print('{0} - {2} - {1}'.format(a,b,c)) - изменяем порядок
print(f'{a} - {b} - {c}') интерполяция
print(i, end=" ") вывод строкой с пробелами, а не столбиком
print(i, sep="*") разделитель *
print(a, b, sep="\n")
input() - ввод с терминала, строкой
int(input()) целые числа
float(input()) вещественные числа
/ деление в вещественное число
// деление в целых числах
** возведение в степень
round() - округление до целого по мат. правилам
round(число, 4) - округление до 4 знаков 
'qwer' * 3 = 'qwerqwerqwer'
 Порядок мат. операцийЖ **, унарный+, унарный-, *, /, //, %, +, -
+= 5 - прибавить к переменной 5, *=5
Логические операции: >, <, >=, <=, ==, !=, not, and, or
пОРЯДОК ЛОГИЧЕСКИХ ОПЕРАЦИЙ: (), !, &, ||
is, is not, in, not in
----------
f=[1,2] (2 in f) это true, 2 содержится в f
f=[1,2] (not 2 in f) это false, 2 содержится в f
is_odd = f[0] % 2 == 0, или (not f[0] % 2) число 1 не четное
----------
if условие:
    действие
else:
    действие
----------
if условие:
    действие
elif условие:
    действие
elif условие:
    действие
else:
    действие
-------------
while условие:
    действие
    действие
    действие
-------------
while условие:
    действие
    действие
else:        - когда основное тело цикла перестает работать
    действие
    действие 
-------------
for i in итерируемый_объект:
    действие
    действие
-------------
range(10) от 0 до 9
range(1, 4) - 1,2,3
range(1, 4, 2) - третий аргумент приращение, выведет 1,3
for i in range(numb - 1, 1, -1): числа в обратном порядке убывают
for i, v in enumerate(list) - возвращает кортеж значений индекс-значение
for i, v in items(dictionary) - возвращает кортеж значений ключ-значение
----------------
базовые API для работы со строками
dir(srt) справка по методам строк
len(text) количество символов строки
text.count(text2) количество вхождений текста2 в текст
'часть строки' in text - true/false - поиск части строки
text.split(",", 2) - разбивает строку на подстроки по разделителю ",". по умолчанию пробел. 2 -сколько запятых разделяет, потом нет
text.isdigit() - true/false - являются ли все символы строки числами
text.islower() - true/false - являются ли все символы нижним регистром
text.replace('что_заменить', 'на_что_заменить')
text.strip() - по умолчанию убирает сомволы по краям пробелы и системные числа
text.strip(",") - убирает символ, можно много разных символов по краям
text.title() — каждое слово в строке начинается с заглавной буквы;
text.lower() — текст переводится в нижний регистр;
text.upper() — текст переводится в верхний регистр;
text.swapcase() – переводит символы верхнего регистра в нижний, а нижний в верхний;
for c in text: 
Срезы:
text='съешь еще этих мягких булок'
text[0] - с
text[4] - ь
text[len(text)-1] - к
text[-5] - б индекс с конца
text[:] - весь текст, 0 и последний символ можно не писать
text[:2] - съе 0 можно не писать
text[1:2] - ъе
text[len(text-2):] - ок
text[6:-18] - еще этих мягких
text[0:len(text):6] - сеикакл
text[::6] - сеикакл
text=text[2:9] + text[-5]+text[:2]
-----------
help(функция) - встроенная справка
------------
СПИСКИ
num = [1,2,3,4]
или
ran = range(1,6) - тип range
num = list(ran) - тип list (список, массив) будет содержать цифры от 1 до 5
list_numbers = list(range(-number, number+1))
num[0]=значение - присвоить значение
len(num) - длина списка
num.append(элемент) - добавляет в конец элемент
num.remove(элемент) - удаляет элемент
num.pop() удаляет последный элемент
num.pop(2) удаляет элемент по индексу
num.insert(2, элемент) добавление элемента по индексу 2
del num[индекс] - удалить элемент конкретного индекса
list1=list2 - ссылки, ведут к одному списку

LIST COMPREHENSION:
    list=[i for i in range(1, 101)]
    list=[i for i in range(1, 101) if i % 2 == 0]
    list=[(i, i*2) for i in range(1, 101) if i % 2 == 0] // создает кортежи из чисел от 1 до 100 если они четные
    list=[f(i) for i in range(1, 101) if i % 2 == 0] // применяет функцию к i
--------------------
ФУНКЦИИ
def имя_функции(аргумент = значение): #значение по умолчанию, применяется если не ввели аргумент
    действие
    действие
    если нужно return
def function(*arg): - *обозначает неограниченное количество аргументов
    for item in arg: перебор всех агрументов
        действие
    return что-что
def fib(n):    рекурсия
    if n in [1,2]:  условие выхода
        return 1
    else:
        return fib(n-1)+fib(n-2)

import название файла - подключение функций
print(hello.function(arg)) используем функцию function из другого файла hello
import файл as fail - использование алиас (псевдонима) после as свое название
print(свое_название.function(1))
-------------------
math.sqrt(numb) - квадрат числа или  numb ** 0,5
print(f'{811 ** 0,5:0.4}') форматирование f строк, округление числа до 4 знаков
round(number) округление
-------------------

РАБОТА С ФАЙЛАМИ    
a - открытие для добавление данных
r - открытие для чтения
w - открытие для записи (затирает старые данные)
w+, r+
вся инфа в файле текст!
data = open('file.txt', 'a') текстовую переменную связываем с фацлом
data.writelines(список) запись в файл списка
     data.write('текст\n')
data.close() разорвать подключение переменной с файлом
exit() - позвляет не выполнять код, который ниже по тексту
или with open('file.txt', 'a') as data:
    data.writelines(список) запись в файл списка
    data.write('текст\n') - связь разрывается автоматом
чтение:
path='file.txt' путь к файлу
data=open(path, 'r') чтение
for line in data: цикл для пробежки по строчкам
    print(line) печать файла  в консоль
data.close() разрыв связи
data.readlines() считывает все строки файла и записывает в список и добавдяет \n
-----------------------------------
КОРТЕЖ - tuple - НЕИЗМЕНЯЕМЫЙ Список
(a,b) = (3,4) это (a=3, b=4)
записывается а=(3,2, 4)
a[0] это 3
a[-1] это 4
a[2]=656565 невозможно, тк список неизменяемый (кортеж)
t=() // typeof(t) is tuple
t=(1,)// typeof(t) is tuple
t=(1)// typeof(t) is int будет ошибка. не котеж, а число. надо поставить ,
а=(3,2, 4) //typeof(a) is tuple
t=tuple(array) //typeof(t) is tuple ()
for item in t: - перебор кортежа
распаковка кортежа:
t=tuple(['red', 'green', 'blue']) создаем кортеж из спискаю двойное преобразование
red, green, blue = t присваиваем независимым переменным элементы кортежа
print('r:{} g:{} b:{}'.format(red, green, blue)) выводим и получим #r:red g: green b:blue

-------------------------------------
СЛОВАРИ
неупорядоченные коллекции произвольных обьектов с доступом по ключу
dictionary = {}
dictionary = \ нужен чтобы не писать все в 1 сткору
    {
        'up': 'вверх',
        'down': 'вниз',
        'left': 'влево'
    }
dictionary['up'] вывод 'вверх' 
типы ключей могут отличаться
for k in dictionary.keys(): перебор ключей
for k in dictionary.values() перебор значений
for k in dictionary:
    ptint(k) вывод ключей
    print(dictionary[k]) вывод значений
dictionary['up'] = новое значение
del dictionary['left'] удаление элемента
for item in dictionary:
    print('{}: {}'.format(item, dictionary[item])) распечатка пары ключ\значение
------------------------------------------
МНОЖЕСТВА set
colors = {'red', 'green', 'blue'} // typeof(colors) 'set'
colors.add('black') добавление в конец. если такой элемент есть, то ощибок нет и элемент не добавляет
colors.remove('red') удаление элемента. если такого нет, будет ошибка
colors.discard('red') удаление элемента. если такого нет, ошибки не будет
colors.clear() очистить множество
print(colors) # set()

операции с множествами:
a={1, 2, 3, 5, 8}
b={2, 5, 8, 13, 21}
c=a.copy()             множество на основе данного  # c= {1, 2, 3, 5, 8}
u=a.union(b)           объединение            # u={1, 2, 3, 5, 8, 13, 21}
i=a.intersection(b)    пересечение          # i={8, 2, 5}
dl = a.difference(b)   левое          # dl={1,2}
dr = b.difference(a)   правое          # dr = {13, 21}
q = a \
    .union(b) \
    .difference(a.intersection(b)) #{1, 21, 3, 13}
s = frozenset(a) замороженное (неизменяемое) множество
---------------------------------------------
import random Подключение модуля рандома

from random import sample  # sample возвращает набор в виде списка
sample(range(1, num_length*2), num_length) # берет цифры из последовательности range(1, num*2) и второй параметр сколько чисел возьмет и перемешает

from random import choices
choices(word, k=3) список составили из  букв word, k внутренний параметр количество символов

uniform(x, y) метод возвращает вещественное число r такое, что x <= r < y
random.random() — возвращает псевдослучайное число от 0.0 до 1.0
random.uniform(<Начало>, <Конец>) — возвращает псевдослучайное вещественное число в диапазоне
random.randint(<Начало>, <Конец>) — возвращает псевдослучайное целое число в диапазоне
random.choince(<Последовательность>) — возвращает случайный элемент из любой последовательности (строки, списка, кортежа):
random.randrange(<Начало>, <Конец>, <Шаг>) — возвращает случайно выбранное число из последовательности.
random.shuffle(<Список>) — перемешивает последовательность (изменяется сама последовательность).
--------------------
Lambda функции, анонимные функции
def f(x):
    return x **2
g = f переменная хранит ссылку на функцию (переменная с типом функция)
g(2) #возвращает тоже 4
def math(funk, x):
    print(funk(x)) т.е. math(f, 3) #print(f(3))  #6ф
function(lambda q, w: q+w, 3, 4) #7
-------------------
map()
map(function, collect) # функция map() применяет указанную функцию к каждому элементу итерируемого объекта и возвращает итератор с новыми обьектами
надо распаковывать в список! 
нельзя пройтись дважды
res = list(map(lambda x: x+10, res)) #получается map object, поэтому надо перепаковать в список
data = list(map(int, input().split()))
--------------------
filter()
применяет указанную функцию к каждому элементу итерируемого объекта и возвращает итератор с теми обьектами, которые вернули true
надо распаковывать в список! 
нельзя пройтись дважды
data=list(filter(lambda x: not x%2, data)) - список четных чисел
----------------------
zip()
возвращает итератор с кортежами из элементов входных данных
zip(list1, list2, list3) вернет [(list1[0], list2[0], list3[0]), (list1[1], list2[1], list3[1]) и т.д.]
надо распаковывать в список! 
нельзя пройтись дважды
выводит массив кортежей НАИМЕНЬШЕЙ длины входящих массивов
-----------------------
enumerate()
возвращает список кортежей из индекса и элементов входящих значений(нумерует)
enumerate(['ddd', 'eee', 'fff']) получаем [(0, 'ddd'), (1, 'eee'), (2, 'fff')]
